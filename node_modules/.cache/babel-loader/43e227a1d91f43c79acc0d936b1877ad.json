{"ast":null,"code":"var _s = $RefreshSig$();\nimport React, { useCallback, useRef, useState } from \"react\";\nlet useInfiniteScroller = () => {\n  _s();\n  const [scrollFetch, setScrollFetch] = useState(true);\n  let observerRef = useRef();\n  const callbackRef = useCallback(node => {\n    if (observerRef.current) observerRef.current.disconnect();\n    observerRef.current = new IntersectionObserver(entries => {\n      var _entries$;\n      if ((_entries$ = entries[0]) !== null && _entries$ !== void 0 && _entries$.isIntersecting) {\n        setScrollFetch(boolVal => !boolVal);\n      }\n    });\n    if (node) observerRef.current.observe(node);\n  }, []);\n  let InfiniteScroll = _ref => {\n    let {\n      children\n    } = _ref;\n    console.log(React.Children.count(children));\n    return React.Children.map(children, child => {\n      return /*#__PURE__*/React.cloneElement(child, {\n        ref: callbackRef\n      });\n    });\n  };\n  return {\n    callbackRef,\n    scrollFetch,\n    setScrollFetch,\n    InfiniteScroll\n  };\n};\n_s(useInfiniteScroller, \"bYec8mbukZq/bj/w6O3kYBEUTYc=\");\nexport default useInfiniteScroller;","map":{"version":3,"names":["React","useCallback","useRef","useState","useInfiniteScroller","scrollFetch","setScrollFetch","observerRef","callbackRef","node","current","disconnect","IntersectionObserver","entries","isIntersecting","boolVal","observe","InfiniteScroll","children","console","log","Children","count","map","child","cloneElement","ref"],"sources":["/home/pwn0x80/Documents/projects/radio/src/utils/useScrollFetch.jsx"],"sourcesContent":["import React, { useCallback, useRef, useState } from \"react\";\n\nlet useInfiniteScroller = () => {\n  const [scrollFetch, setScrollFetch] = useState(true)\n  let observerRef = useRef();\n  const callbackRef = useCallback(node => {\n    if (observerRef.current) observerRef.current.disconnect()\n    observerRef.current = new IntersectionObserver(entries => {\n      if (entries[0]?.isIntersecting) {\n        setScrollFetch((boolVal) => !boolVal)\n      }\n    })\n    if (node) observerRef.current.observe(node)\n  }, [])\n  let InfiniteScroll = ({ children }) => {\n\n    console.log(React.Children.count(children))\n    return React.Children.map(children, child => {\n      return React.cloneElement(child, { ref: callbackRef })\n    })\n  }\n  return {\n    callbackRef, scrollFetch, setScrollFetch, InfiniteScroll\n  }\n}\nexport default useInfiniteScroller\n"],"mappings":";AAAA,OAAOA,KAAK,IAAIC,WAAW,EAAEC,MAAM,EAAEC,QAAQ,QAAQ,OAAO;AAE5D,IAAIC,mBAAmB,GAAG,MAAM;EAAA;EAC9B,MAAM,CAACC,WAAW,EAAEC,cAAc,CAAC,GAAGH,QAAQ,CAAC,IAAI,CAAC;EACpD,IAAII,WAAW,GAAGL,MAAM,EAAE;EAC1B,MAAMM,WAAW,GAAGP,WAAW,CAACQ,IAAI,IAAI;IACtC,IAAIF,WAAW,CAACG,OAAO,EAAEH,WAAW,CAACG,OAAO,CAACC,UAAU,EAAE;IACzDJ,WAAW,CAACG,OAAO,GAAG,IAAIE,oBAAoB,CAACC,OAAO,IAAI;MAAA;MACxD,iBAAIA,OAAO,CAAC,CAAC,CAAC,sCAAV,UAAYC,cAAc,EAAE;QAC9BR,cAAc,CAAES,OAAO,IAAK,CAACA,OAAO,CAAC;MACvC;IACF,CAAC,CAAC;IACF,IAAIN,IAAI,EAAEF,WAAW,CAACG,OAAO,CAACM,OAAO,CAACP,IAAI,CAAC;EAC7C,CAAC,EAAE,EAAE,CAAC;EACN,IAAIQ,cAAc,GAAG,QAAkB;IAAA,IAAjB;MAAEC;IAAS,CAAC;IAEhCC,OAAO,CAACC,GAAG,CAACpB,KAAK,CAACqB,QAAQ,CAACC,KAAK,CAACJ,QAAQ,CAAC,CAAC;IAC3C,OAAOlB,KAAK,CAACqB,QAAQ,CAACE,GAAG,CAACL,QAAQ,EAAEM,KAAK,IAAI;MAC3C,oBAAOxB,KAAK,CAACyB,YAAY,CAACD,KAAK,EAAE;QAAEE,GAAG,EAAElB;MAAY,CAAC,CAAC;IACxD,CAAC,CAAC;EACJ,CAAC;EACD,OAAO;IACLA,WAAW;IAAEH,WAAW;IAAEC,cAAc;IAAEW;EAC5C,CAAC;AACH,CAAC;AAAA,GAtBGb,mBAAmB;AAuBvB,eAAeA,mBAAmB"},"metadata":{},"sourceType":"module"}