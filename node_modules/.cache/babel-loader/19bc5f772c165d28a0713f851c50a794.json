{"ast":null,"code":"var _s = $RefreshSig$();\nimport React, { useCallback, useRef, useState } from \"react\";\nlet useInfiniteScroller = () => {\n  _s();\n  const [scrollFetch, setScrollFetch] = useState(true);\n  let observerRef = useRef();\n  const callbackRef = useCallback(node => {\n    if (observerRef.current) observerRef.current.disconnect();\n    observerRef.current = new IntersectionObserver(entries => {\n      var _entries$;\n      console.log(\"hi\");\n      if ((_entries$ = entries[0]) !== null && _entries$ !== void 0 && _entries$.isIntersecting) {\n        setScrollFetch(boolVal => !boolVal);\n      }\n    });\n    if (node) observerRef.current.observe(node);\n  }, []);\n  let InfiniteScroll = useCallback(_ref => {\n    let {\n      len,\n      children\n    } = _ref;\n    console.log(len);\n    console.log(\"inside callback\");\n    console.log(React.Children.count(children));\n    return React.Children.map(children, child => {\n      return /*#__PURE__*/React.cloneElement(child, {\n        ref: callbackRef\n      });\n    });\n  }, []);\n  return {\n    callbackRef,\n    scrollFetch,\n    setScrollFetch,\n    InfiniteScroll\n  };\n};\n_s(useInfiniteScroller, \"NIPIJNYY5nUPcxyxiB09dgv9vv8=\");\nexport default useInfiniteScroller;","map":{"version":3,"names":["React","useCallback","useRef","useState","useInfiniteScroller","scrollFetch","setScrollFetch","observerRef","callbackRef","node","current","disconnect","IntersectionObserver","entries","console","log","isIntersecting","boolVal","observe","InfiniteScroll","len","children","Children","count","map","child","cloneElement","ref"],"sources":["/home/pwn0x80/Documents/projects/radio/src/utils/useScrollFetch.jsx"],"sourcesContent":["import React, { useCallback, useRef, useState } from \"react\";\n\nlet useInfiniteScroller = () => {\n  const [scrollFetch, setScrollFetch] = useState(true)\n  let observerRef = useRef();\n  const callbackRef = useCallback(node => {\n    if (observerRef.current) observerRef.current.disconnect()\n    observerRef.current = new IntersectionObserver(entries => {\n      console.log(\"hi\")\n      if (entries[0]?.isIntersecting) {\n        setScrollFetch((boolVal) => !boolVal)\n\n      }\n    })\n    if (node) observerRef.current.observe(node)\n  }, [])\n  let InfiniteScroll = useCallback(({ len, children }) => {\n    console.log(len)\n    console.log(\"inside callback\")\n    console.log(React.Children.count(children))\n    return React.Children.map(children, child => {\n      return React.cloneElement(child, { ref: callbackRef })\n\n    })\n  }, [])\n  return {\n    callbackRef, scrollFetch, setScrollFetch, InfiniteScroll\n  }\n}\nexport default useInfiniteScroller\n"],"mappings":";AAAA,OAAOA,KAAK,IAAIC,WAAW,EAAEC,MAAM,EAAEC,QAAQ,QAAQ,OAAO;AAE5D,IAAIC,mBAAmB,GAAG,MAAM;EAAA;EAC9B,MAAM,CAACC,WAAW,EAAEC,cAAc,CAAC,GAAGH,QAAQ,CAAC,IAAI,CAAC;EACpD,IAAII,WAAW,GAAGL,MAAM,EAAE;EAC1B,MAAMM,WAAW,GAAGP,WAAW,CAACQ,IAAI,IAAI;IACtC,IAAIF,WAAW,CAACG,OAAO,EAAEH,WAAW,CAACG,OAAO,CAACC,UAAU,EAAE;IACzDJ,WAAW,CAACG,OAAO,GAAG,IAAIE,oBAAoB,CAACC,OAAO,IAAI;MAAA;MACxDC,OAAO,CAACC,GAAG,CAAC,IAAI,CAAC;MACjB,iBAAIF,OAAO,CAAC,CAAC,CAAC,sCAAV,UAAYG,cAAc,EAAE;QAC9BV,cAAc,CAAEW,OAAO,IAAK,CAACA,OAAO,CAAC;MAEvC;IACF,CAAC,CAAC;IACF,IAAIR,IAAI,EAAEF,WAAW,CAACG,OAAO,CAACQ,OAAO,CAACT,IAAI,CAAC;EAC7C,CAAC,EAAE,EAAE,CAAC;EACN,IAAIU,cAAc,GAAGlB,WAAW,CAAC,QAAuB;IAAA,IAAtB;MAAEmB,GAAG;MAAEC;IAAS,CAAC;IACjDP,OAAO,CAACC,GAAG,CAACK,GAAG,CAAC;IAChBN,OAAO,CAACC,GAAG,CAAC,iBAAiB,CAAC;IAC9BD,OAAO,CAACC,GAAG,CAACf,KAAK,CAACsB,QAAQ,CAACC,KAAK,CAACF,QAAQ,CAAC,CAAC;IAC3C,OAAOrB,KAAK,CAACsB,QAAQ,CAACE,GAAG,CAACH,QAAQ,EAAEI,KAAK,IAAI;MAC3C,oBAAOzB,KAAK,CAAC0B,YAAY,CAACD,KAAK,EAAE;QAAEE,GAAG,EAAEnB;MAAY,CAAC,CAAC;IAExD,CAAC,CAAC;EACJ,CAAC,EAAE,EAAE,CAAC;EACN,OAAO;IACLA,WAAW;IAAEH,WAAW;IAAEC,cAAc;IAAEa;EAC5C,CAAC;AACH,CAAC;AAAA,GA1BGf,mBAAmB;AA2BvB,eAAeA,mBAAmB"},"metadata":{},"sourceType":"module"}