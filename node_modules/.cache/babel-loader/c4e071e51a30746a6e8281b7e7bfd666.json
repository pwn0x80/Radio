{"ast":null,"code":"var _s = $RefreshSig$();\nimport React, { useCallback, useRef, useState } from \"react\";\nlet useInfiniteScroller = () => {\n  _s();\n  const [scrollFetch, setScrollFetch] = useState(true);\n  let observerRef = useRef();\n  const callbackRef = useCallback(node => {\n    if (observerRef.current) observerRef.current.disconnect();\n    observerRef.current = new IntersectionObserver(entries => {\n      var _entries$;\n      if ((_entries$ = entries[0]) !== null && _entries$ !== void 0 && _entries$.isIntersecting) {\n        setScrollFetch(boolVal => !boolVal);\n      }\n    });\n    if (node) observerRef.current.observe(node);\n  }, []);\n  let InfiniteScroll = useCallback(_ref => {\n    let {\n      len,\n      children\n    } = _ref;\n    return React.Children.map(children, child => {\n      if (children.key == len - 3) {\n        return /*#__PURE__*/React.cloneElement(child, {\n          ref: callbackRef\n        });\n      } else {\n        return /*#__PURE__*/React.cloneElement(child, {});\n      }\n    });\n  }, []);\n  return {\n    callbackRef,\n    scrollFetch,\n    setScrollFetch,\n    InfiniteScroll\n  };\n};\n_s(useInfiniteScroller, \"NIPIJNYY5nUPcxyxiB09dgv9vv8=\");\nexport default useInfiniteScroller;","map":{"version":3,"names":["React","useCallback","useRef","useState","useInfiniteScroller","scrollFetch","setScrollFetch","observerRef","callbackRef","node","current","disconnect","IntersectionObserver","entries","isIntersecting","boolVal","observe","InfiniteScroll","len","children","Children","map","child","key","cloneElement","ref"],"sources":["/home/pwn0x80/Documents/projects/radio/src/utils/useScrollFetch.jsx"],"sourcesContent":["import React, { useCallback, useRef, useState } from \"react\";\n\nlet useInfiniteScroller = () => {\n  const [scrollFetch, setScrollFetch] = useState(true)\n  let observerRef = useRef();\n  const callbackRef = useCallback(node => {\n    if (observerRef.current) observerRef.current.disconnect()\n    observerRef.current = new IntersectionObserver(entries => {\n      if (entries[0]?.isIntersecting) {\n        setScrollFetch((boolVal) => !boolVal)\n\n      }\n    })\n    if (node) observerRef.current.observe(node)\n  }, [])\n  let InfiniteScroll = useCallback(({ len, children }) => {\n    return React.Children.map(children, child => {\n      if (children.key == len - 3) {\n        return React.cloneElement(child, { ref: callbackRef })\n      } else {\n        return React.cloneElement(child, {})\n      }\n    })\n  }, [])\n  return {\n    callbackRef, scrollFetch, setScrollFetch, InfiniteScroll\n  }\n}\nexport default useInfiniteScroller\n"],"mappings":";AAAA,OAAOA,KAAK,IAAIC,WAAW,EAAEC,MAAM,EAAEC,QAAQ,QAAQ,OAAO;AAE5D,IAAIC,mBAAmB,GAAG,MAAM;EAAA;EAC9B,MAAM,CAACC,WAAW,EAAEC,cAAc,CAAC,GAAGH,QAAQ,CAAC,IAAI,CAAC;EACpD,IAAII,WAAW,GAAGL,MAAM,EAAE;EAC1B,MAAMM,WAAW,GAAGP,WAAW,CAACQ,IAAI,IAAI;IACtC,IAAIF,WAAW,CAACG,OAAO,EAAEH,WAAW,CAACG,OAAO,CAACC,UAAU,EAAE;IACzDJ,WAAW,CAACG,OAAO,GAAG,IAAIE,oBAAoB,CAACC,OAAO,IAAI;MAAA;MACxD,iBAAIA,OAAO,CAAC,CAAC,CAAC,sCAAV,UAAYC,cAAc,EAAE;QAC9BR,cAAc,CAAES,OAAO,IAAK,CAACA,OAAO,CAAC;MAEvC;IACF,CAAC,CAAC;IACF,IAAIN,IAAI,EAAEF,WAAW,CAACG,OAAO,CAACM,OAAO,CAACP,IAAI,CAAC;EAC7C,CAAC,EAAE,EAAE,CAAC;EACN,IAAIQ,cAAc,GAAGhB,WAAW,CAAC,QAAuB;IAAA,IAAtB;MAAEiB,GAAG;MAAEC;IAAS,CAAC;IACjD,OAAOnB,KAAK,CAACoB,QAAQ,CAACC,GAAG,CAACF,QAAQ,EAAEG,KAAK,IAAI;MAC3C,IAAIH,QAAQ,CAACI,GAAG,IAAIL,GAAG,GAAG,CAAC,EAAE;QAC3B,oBAAOlB,KAAK,CAACwB,YAAY,CAACF,KAAK,EAAE;UAAEG,GAAG,EAAEjB;QAAY,CAAC,CAAC;MACxD,CAAC,MAAM;QACL,oBAAOR,KAAK,CAACwB,YAAY,CAACF,KAAK,EAAE,CAAC,CAAC,CAAC;MACtC;IACF,CAAC,CAAC;EACJ,CAAC,EAAE,EAAE,CAAC;EACN,OAAO;IACLd,WAAW;IAAEH,WAAW;IAAEC,cAAc;IAAEW;EAC5C,CAAC;AACH,CAAC;AAAA,GAzBGb,mBAAmB;AA0BvB,eAAeA,mBAAmB"},"metadata":{},"sourceType":"module"}